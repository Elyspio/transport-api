/* tslint:disable */
/* eslint-disable */
/**
 * Transport.Api.Web
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosInstance, AxiosPromise, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
	assertParamExists,
	createRequestFunction,
	DUMMY_BASE_URL,
	serializeDataIfNeeded,
	setApiKeyToObject,
	setBasicAuthToObject,
	setBearerAuthToObject,
	setOAuthToObject,
	setSearchParams,
	toPathString,
} from "./common";
// @ts-ignore
import { BASE_PATH, BaseAPI, COLLECTION_FORMATS, RequestArgs, RequiredError } from "./base";

/**
 *
 * @export
 * @interface Departement
 */
export interface Departement {
	/**
	 *
	 * @type {string}
	 * @memberof Departement
	 */
	name: string;
	/**
	 *
	 * @type {string}
	 * @memberof Departement
	 */
	code: string;
}

/**
 *
 * @export
 * @interface FuelPriceHistory
 */
export interface FuelPriceHistory {
	/**
	 *
	 * @type {string}
	 * @memberof FuelPriceHistory
	 */
	date: string;
	/**
	 *
	 * @type {number}
	 * @memberof FuelPriceHistory
	 */
	value: number;
}

/**
 *
 * @export
 * @interface FuelStationData
 */
export interface FuelStationData {
	/**
	 *
	 * @type {number}
	 * @memberof FuelStationData
	 */
	id: number;
	/**
	 *
	 * @type {Location}
	 * @memberof FuelStationData
	 */
	location: Location;
	/**
	 *
	 * @type {Prices}
	 * @memberof FuelStationData
	 */
	prices: Prices;
	/**
	 *
	 * @type {Array<FuelStationServiceType>}
	 * @memberof FuelStationData
	 */
	services: Array<FuelStationServiceType>;
}

/**
 *
 * @export
 * @interface FuelStationDataDistance
 */
export interface FuelStationDataDistance {
	/**
	 *
	 * @type {number}
	 * @memberof FuelStationDataDistance
	 */
	id: number;
	/**
	 *
	 * @type {Location}
	 * @memberof FuelStationDataDistance
	 */
	location: Location;
	/**
	 *
	 * @type {Prices}
	 * @memberof FuelStationDataDistance
	 */
	prices: Prices;
	/**
	 *
	 * @type {Array<FuelStationServiceType>}
	 * @memberof FuelStationDataDistance
	 */
	services: Array<FuelStationServiceType>;
	/**
	 *
	 * @type {number}
	 * @memberof FuelStationDataDistance
	 */
	distance: number;
}

/**
 *
 * @export
 * @enum {string}
 */

export enum FuelStationServiceType {
	AireDeCampingCars = "AireDeCampingCars",
	AutomateCb2424 = "AutomateCb2424",
	Bar = "Bar",
	Borneslectriques = "BornesÉlectriques",
	BoutiqueAlimentaire = "BoutiqueAlimentaire",
	BoutiqueNonAlimentaire = "BoutiqueNonAlimentaire",
	CarburantAdditiv = "CarburantAdditivé",
	DabDistributeurAutomatiqueDeBillets = "DabDistributeurAutomatiqueDeBillets",
	Douches = "Douches",
	EspaceBb = "EspaceBébé",
	Gnv = "Gnv",
	LavageAutomatique = "LavageAutomatique",
	LavageManuel = "LavageManuel",
	Laverie = "Laverie",
	LocationDeVhicule = "LocationDeVéhicule",
	PistePoidsLourds = "PistePoidsLourds",
	RelaisColis = "RelaisColis",
	RestaurationSurPlace = "RestaurationSurPlace",
	RestaurationEmporter = "RestaurationÀEmporter",
	ServicesRparationEntretien = "ServicesRéparationEntretien",
	StationDeGonflage = "StationDeGonflage",
	ToilettesPubliques = "ToilettesPubliques",
	VenteDAdditifsCarburants = "VenteDAdditifsCarburants",
	VenteDeFioulDomestique = "VenteDeFioulDomestique",
	VenteDeGazDomestiqueButanePropane = "VenteDeGazDomestiqueButanePropane",
	VenteDePtroleLampant = "VenteDePétroleLampant",
	Wifi = "Wifi",
}

/**
 *
 * @export
 * @interface Location
 */
export interface Location {
	/**
	 *
	 * @type {number}
	 * @memberof Location
	 */
	latitude: number;
	/**
	 *
	 * @type {number}
	 * @memberof Location
	 */
	longitude: number;
	/**
	 *
	 * @type {string}
	 * @memberof Location
	 */
	postalCode: string;
	/**
	 *
	 * @type {string}
	 * @memberof Location
	 */
	address: string;
	/**
	 *
	 * @type {string}
	 * @memberof Location
	 */
	city: string;
}

/**
 *
 * @export
 * @interface Prices
 */
export interface Prices {
	/**
	 *
	 * @type {Array<FuelPriceHistory>}
	 * @memberof Prices
	 */
	e10: Array<FuelPriceHistory>;
	/**
	 *
	 * @type {Array<FuelPriceHistory>}
	 * @memberof Prices
	 */
	e85: Array<FuelPriceHistory>;
	/**
	 *
	 * @type {Array<FuelPriceHistory>}
	 * @memberof Prices
	 */
	gazole: Array<FuelPriceHistory>;
	/**
	 *
	 * @type {Array<FuelPriceHistory>}
	 * @memberof Prices
	 */
	gpLc: Array<FuelPriceHistory>;
	/**
	 *
	 * @type {Array<FuelPriceHistory>}
	 * @memberof Prices
	 */
	sp95: Array<FuelPriceHistory>;
	/**
	 *
	 * @type {Array<FuelPriceHistory>}
	 * @memberof Prices
	 */
	sp98: Array<FuelPriceHistory>;
}

/**
 *
 * @export
 * @enum {string}
 */

export enum Region {
	AuvergneRhoneAlpes = "AuvergneRhoneAlpes",
	BourgogneFrancheComte = "BourgogneFrancheComte",
	Bretagne = "Bretagne",
	CentreValDeLoire = "CentreValDeLoire",
	Corse = "Corse",
	GrandEst = "GrandEst",
	HautDeFrance = "HautDeFrance",
	Normandie = "Normandie",
	NouvelleAquitaine = "NouvelleAquitaine",
	IleDeFrance = "IleDeFrance",
	Occitanie = "Occitanie",
	PaysDeLaLoire = "PaysDeLaLoire",
	ProvenceAlpesCoteAzur = "ProvenceAlpesCoteAzur",
	Martinique = "Martinique",
	Guadeloupe = "Guadeloupe",
	Guyane = "Guyane",
	LaReunion = "LaReunion",
	Mayotte = "Mayotte",
}

/**
 *
 * @export
 * @interface RegionTransport
 */
export interface RegionTransport {
	/**
	 *
	 * @type {Region}
	 * @memberof RegionTransport
	 */
	id: Region;
	/**
	 *
	 * @type {string}
	 * @memberof RegionTransport
	 */
	code: string;
	/**
	 *
	 * @type {string}
	 * @memberof RegionTransport
	 */
	label: string;
}

/**
 *
 * @export
 * @interface Statistic
 */
export interface Statistic {
	/**
	 *
	 * @type {string}
	 * @memberof Statistic
	 */
	time: string;
	/**
	 *
	 * @type {string}
	 * @memberof Statistic
	 */
	id: string;
	/**
	 *
	 * @type {StatisticInfo}
	 * @memberof Statistic
	 */
	data: StatisticInfo;
}

/**
 *
 * @export
 * @interface StatisticData
 */
export interface StatisticData {
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof StatisticData
	 */
	average: { [key: string]: number };
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof StatisticData
	 */
	max: { [key: string]: number };
	/**
	 *
	 * @type {{ [key: string]: number; }}
	 * @memberof StatisticData
	 */
	min: { [key: string]: number };
	/**
	 *
	 * @type {Array<{ [key: string]: number; }>}
	 * @memberof StatisticData
	 */
	deciles: Array<{ [key: string]: number }>;
}

/**
 *
 * @export
 * @interface StatisticInfo
 */
export interface StatisticInfo {
	/**
	 *
	 * @type {{ [key: string]: StatisticData; }}
	 * @memberof StatisticInfo
	 */
	cities: { [key: string]: StatisticData };
	/**
	 *
	 * @type {{ [key: string]: StatisticData; }}
	 * @memberof StatisticInfo
	 */
	departements: { [key: string]: StatisticData };
	/**
	 *
	 * @type {{ [key: string]: StatisticData; }}
	 * @memberof StatisticInfo
	 */
	regions: { [key: string]: StatisticData };
}

/**
 *
 * @export
 * @enum {string}
 */

export enum StatsTimeType {
	Year = "Year",
	Month = "Month",
	Month3 = "Month3",
	Month6 = "Month6",
	Week = "Week",
}

/**
 * DatabaseApi - axios parameter creator
 * @export
 */
export const DatabaseApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {number} year
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateYearly: async (year: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'year' is not null or undefined
			assertParamExists("updateYearly", "year", year);
			const localVarPath = `/api/database/prices/{year}/refresh`.replace(`{${"year"}}`, encodeURIComponent(String(year)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PUT", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * DatabaseApi - functional programming interface
 * @export
 */
export const DatabaseApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = DatabaseApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {number} year
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async updateYearly(year: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.updateYearly(year, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * DatabaseApi - factory interface
 * @export
 */
export const DatabaseApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = DatabaseApiFp(configuration);
	return {
		/**
		 *
		 * @param {number} year
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		updateYearly(year: number, options?: any): AxiosPromise<void> {
			return localVarFp.updateYearly(year, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * DatabaseApi - object-oriented interface
 * @export
 * @class DatabaseApi
 * @extends {BaseAPI}
 */
export class DatabaseApi extends BaseAPI {
	/**
	 *
	 * @param {number} year
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof DatabaseApi
	 */
	public updateYearly(year: number, options?: AxiosRequestConfig) {
		return DatabaseApiFp(this.configuration)
			.updateYearly(year, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * FuelStationsApi - axios parameter creator
 * @export
 */
export const FuelStationsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {string} [minDate]
		 * @param {string} [maxDate]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFuelStationsBetweenDates: async (minDate?: string, maxDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/fuel-stations/history`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (minDate !== undefined) {
				localVarQueryParameter["minDate"] = (minDate as any) instanceof Date ? (minDate as any).toISOString() : minDate;
			}

			if (maxDate !== undefined) {
				localVarQueryParameter["maxDate"] = (maxDate as any) instanceof Date ? (maxDate as any).toISOString() : maxDate;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {number} latitude
		 * @param {number} longitude
		 * @param {number} [radius]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFuelStationsNear: async (latitude: number, longitude: number, radius?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'latitude' is not null or undefined
			assertParamExists("getFuelStationsNear", "latitude", latitude);
			// verify required parameter 'longitude' is not null or undefined
			assertParamExists("getFuelStationsNear", "longitude", longitude);
			const localVarPath = `/api/fuel-stations/near`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (latitude !== undefined) {
				localVarQueryParameter["latitude"] = latitude;
			}

			if (longitude !== undefined) {
				localVarQueryParameter["longitude"] = longitude;
			}

			if (radius !== undefined) {
				localVarQueryParameter["radius"] = radius;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * FuelStationsApi - functional programming interface
 * @export
 */
export const FuelStationsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = FuelStationsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {string} [minDate]
		 * @param {string} [maxDate]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getFuelStationsBetweenDates(
			minDate?: string,
			maxDate?: string,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FuelStationData>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getFuelStationsBetweenDates(minDate, maxDate, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {number} latitude
		 * @param {number} longitude
		 * @param {number} [radius]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getFuelStationsNear(
			latitude: number,
			longitude: number,
			radius?: number,
			options?: AxiosRequestConfig
		): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FuelStationDataDistance>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getFuelStationsNear(latitude, longitude, radius, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * FuelStationsApi - factory interface
 * @export
 */
export const FuelStationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = FuelStationsApiFp(configuration);
	return {
		/**
		 *
		 * @param {string} [minDate]
		 * @param {string} [maxDate]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFuelStationsBetweenDates(minDate?: string, maxDate?: string, options?: any): AxiosPromise<Array<FuelStationData>> {
			return localVarFp.getFuelStationsBetweenDates(minDate, maxDate, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {number} latitude
		 * @param {number} longitude
		 * @param {number} [radius]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getFuelStationsNear(latitude: number, longitude: number, radius?: number, options?: any): AxiosPromise<Array<FuelStationDataDistance>> {
			return localVarFp.getFuelStationsNear(latitude, longitude, radius, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * FuelStationsApi - object-oriented interface
 * @export
 * @class FuelStationsApi
 * @extends {BaseAPI}
 */
export class FuelStationsApi extends BaseAPI {
	/**
	 *
	 * @param {string} [minDate]
	 * @param {string} [maxDate]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof FuelStationsApi
	 */
	public getFuelStationsBetweenDates(minDate?: string, maxDate?: string, options?: AxiosRequestConfig) {
		return FuelStationsApiFp(this.configuration)
			.getFuelStationsBetweenDates(minDate, maxDate, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {number} latitude
	 * @param {number} longitude
	 * @param {number} [radius]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof FuelStationsApi
	 */
	public getFuelStationsNear(latitude: number, longitude: number, radius?: number, options?: AxiosRequestConfig) {
		return FuelStationsApiFp(this.configuration)
			.getFuelStationsNear(latitude, longitude, radius, options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * LocationsApi - axios parameter creator
 * @export
 */
export const LocationsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllDepartements: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/Locations/departements`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {Region} region
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDepartementsByRegion: async (region: Region, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'region' is not null or undefined
			assertParamExists("getDepartementsByRegion", "region", region);
			const localVarPath = `/api/Locations/regions/{region}/departements`.replace(`{${"region"}}`, encodeURIComponent(String(region)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRegions: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/Locations/regions`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/Locations/regions`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * LocationsApi - functional programming interface
 * @export
 */
export const LocationsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = LocationsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getAllDepartements(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Departement>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDepartements(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {Region} region
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getDepartementsByRegion(region: Region, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Departement>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getDepartementsByRegion(region, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getRegions(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegionTransport>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getRegions(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async refresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * LocationsApi - factory interface
 * @export
 */
export const LocationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = LocationsApiFp(configuration);
	return {
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getAllDepartements(options?: any): AxiosPromise<Array<Departement>> {
			return localVarFp.getAllDepartements(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {Region} region
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getDepartementsByRegion(region: Region, options?: any): AxiosPromise<Array<Departement>> {
			return localVarFp.getDepartementsByRegion(region, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getRegions(options?: any): AxiosPromise<Array<RegionTransport>> {
			return localVarFp.getRegions(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refresh(options?: any): AxiosPromise<void> {
			return localVarFp.refresh(options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * LocationsApi - object-oriented interface
 * @export
 * @class LocationsApi
 * @extends {BaseAPI}
 */
export class LocationsApi extends BaseAPI {
	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public getAllDepartements(options?: AxiosRequestConfig) {
		return LocationsApiFp(this.configuration)
			.getAllDepartements(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {Region} region
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public getDepartementsByRegion(region: Region, options?: AxiosRequestConfig) {
		return LocationsApiFp(this.configuration)
			.getDepartementsByRegion(region, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public getRegions(options?: AxiosRequestConfig) {
		return LocationsApiFp(this.configuration)
			.getRegions(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof LocationsApi
	 */
	public refresh(options?: AxiosRequestConfig) {
		return LocationsApiFp(this.configuration)
			.refresh(options)
			.then((request) => request(this.axios, this.basePath));
	}
}

/**
 * StatisticsApi - axios parameter creator
 * @export
 */
export const StatisticsApiAxiosParamCreator = function (configuration?: Configuration) {
	return {
		/**
		 *
		 * @param {StatsTimeType} statsTimeType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getWeeklyStats: async (statsTimeType: StatsTimeType, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'statsTimeType' is not null or undefined
			assertParamExists("getWeeklyStats", "statsTimeType", statsTimeType);
			const localVarPath = `/api/statistics/{statsTimeType}`.replace(`{${"statsTimeType"}}`, encodeURIComponent(String(statsTimeType)));
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refresh: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			const localVarPath = `/api/statistics/refresh`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {boolean} clear
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshDailyStats: async (clear: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'clear' is not null or undefined
			assertParamExists("refreshDailyStats", "clear", clear);
			const localVarPath = `/api/statistics/refresh/daily`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (clear !== undefined) {
				localVarQueryParameter["clear"] = clear;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
		/**
		 *
		 * @param {boolean} clear
		 * @param {number} [year]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshWeeklyStats: async (clear: boolean, year?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
			// verify required parameter 'clear' is not null or undefined
			assertParamExists("refreshWeeklyStats", "clear", clear);
			const localVarPath = `/api/statistics/refresh/weekly`;
			// use dummy base URL string because the URL constructor only accepts absolute URLs.
			const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
			let baseOptions;
			if (configuration) {
				baseOptions = configuration.baseOptions;
			}

			const localVarRequestOptions = { method: "PATCH", ...baseOptions, ...options };
			const localVarHeaderParameter = {} as any;
			const localVarQueryParameter = {} as any;

			if (clear !== undefined) {
				localVarQueryParameter["clear"] = clear;
			}

			if (year !== undefined) {
				localVarQueryParameter["year"] = year;
			}

			setSearchParams(localVarUrlObj, localVarQueryParameter);
			let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
			localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

			return {
				url: toPathString(localVarUrlObj),
				options: localVarRequestOptions,
			};
		},
	};
};

/**
 * StatisticsApi - functional programming interface
 * @export
 */
export const StatisticsApiFp = function (configuration?: Configuration) {
	const localVarAxiosParamCreator = StatisticsApiAxiosParamCreator(configuration);
	return {
		/**
		 *
		 * @param {StatsTimeType} statsTimeType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async getWeeklyStats(statsTimeType: StatsTimeType, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Statistic>>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.getWeeklyStats(statsTimeType, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async refresh(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.refresh(options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {boolean} clear
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async refreshDailyStats(clear: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.refreshDailyStats(clear, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
		/**
		 *
		 * @param {boolean} clear
		 * @param {number} [year]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		async refreshWeeklyStats(clear: boolean, year?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
			const localVarAxiosArgs = await localVarAxiosParamCreator.refreshWeeklyStats(clear, year, options);
			return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
		},
	};
};

/**
 * StatisticsApi - factory interface
 * @export
 */
export const StatisticsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
	const localVarFp = StatisticsApiFp(configuration);
	return {
		/**
		 *
		 * @param {StatsTimeType} statsTimeType
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		getWeeklyStats(statsTimeType: StatsTimeType, options?: any): AxiosPromise<Array<Statistic>> {
			return localVarFp.getWeeklyStats(statsTimeType, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refresh(options?: any): AxiosPromise<void> {
			return localVarFp.refresh(options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {boolean} clear
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshDailyStats(clear: boolean, options?: any): AxiosPromise<void> {
			return localVarFp.refreshDailyStats(clear, options).then((request) => request(axios, basePath));
		},
		/**
		 *
		 * @param {boolean} clear
		 * @param {number} [year]
		 * @param {*} [options] Override http request option.
		 * @throws {RequiredError}
		 */
		refreshWeeklyStats(clear: boolean, year?: number, options?: any): AxiosPromise<void> {
			return localVarFp.refreshWeeklyStats(clear, year, options).then((request) => request(axios, basePath));
		},
	};
};

/**
 * StatisticsApi - object-oriented interface
 * @export
 * @class StatisticsApi
 * @extends {BaseAPI}
 */
export class StatisticsApi extends BaseAPI {
	/**
	 *
	 * @param {StatsTimeType} statsTimeType
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StatisticsApi
	 */
	public getWeeklyStats(statsTimeType: StatsTimeType, options?: AxiosRequestConfig) {
		return StatisticsApiFp(this.configuration)
			.getWeeklyStats(statsTimeType, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StatisticsApi
	 */
	public refresh(options?: AxiosRequestConfig) {
		return StatisticsApiFp(this.configuration)
			.refresh(options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {boolean} clear
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StatisticsApi
	 */
	public refreshDailyStats(clear: boolean, options?: AxiosRequestConfig) {
		return StatisticsApiFp(this.configuration)
			.refreshDailyStats(clear, options)
			.then((request) => request(this.axios, this.basePath));
	}

	/**
	 *
	 * @param {boolean} clear
	 * @param {number} [year]
	 * @param {*} [options] Override http request option.
	 * @throws {RequiredError}
	 * @memberof StatisticsApi
	 */
	public refreshWeeklyStats(clear: boolean, year?: number, options?: AxiosRequestConfig) {
		return StatisticsApiFp(this.configuration)
			.refreshWeeklyStats(clear, year, options)
			.then((request) => request(this.axios, this.basePath));
	}
}
